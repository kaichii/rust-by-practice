<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust By Practice</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Learn Rust with Example, Exercise and real Practice, written with â¤ï¸ by https://course.rs team">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="why-exercise.html"><strong aria-hidden="true">1.</strong> Rust By Practice</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">2.</strong> Variables</a></li><li class="chapter-item expanded "><a href="basic-types/intro.html"><strong aria-hidden="true">3.</strong> Basic Types</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-types/numbers.html"><strong aria-hidden="true">3.1.</strong> Numbers</a></li><li class="chapter-item "><a href="basic-types/char-bool-unit.html"><strong aria-hidden="true">3.2.</strong> Char, Bool and Unit</a></li><li class="chapter-item "><a href="basic-types/statements-expressions.html"><strong aria-hidden="true">3.3.</strong> Statements and Expressions</a></li><li class="chapter-item "><a href="basic-types/functions.html"><strong aria-hidden="true">3.4.</strong> Functions</a></li></ol></li><li class="chapter-item expanded "><a href="ownership/intro.html"><strong aria-hidden="true">4.</strong> Ownership and Borrowing</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ownership/ownership.html"><strong aria-hidden="true">4.1.</strong> Ownership</a></li><li class="chapter-item "><a href="ownership/borrowing.html"><strong aria-hidden="true">4.2.</strong> Reference and Borrowing</a></li></ol></li><li class="chapter-item expanded "><a href="compound-types/intro.html"><strong aria-hidden="true">5.</strong> Compound Types</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compound-types/string.html"><strong aria-hidden="true">5.1.</strong> string</a></li><li class="chapter-item "><a href="compound-types/array.html"><strong aria-hidden="true">5.2.</strong> Array</a></li><li class="chapter-item "><a href="compound-types/slice.html"><strong aria-hidden="true">5.3.</strong> Slice</a></li><li class="chapter-item "><a href="compound-types/tuple.html"><strong aria-hidden="true">5.4.</strong> Tuple</a></li><li class="chapter-item "><a href="compound-types/struct.html"><strong aria-hidden="true">5.5.</strong> Struct</a></li><li class="chapter-item "><a href="compound-types/enum.html"><strong aria-hidden="true">5.6.</strong> Enum</a></li></ol></li><li class="chapter-item expanded "><a href="flow-control.html"><strong aria-hidden="true">6.</strong> Flow Control</a></li><li class="chapter-item expanded "><a href="pattern-match/intro.html"><strong aria-hidden="true">7.</strong> Pattern Match</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pattern-match/match-iflet.html"><strong aria-hidden="true">7.1.</strong> match, matches! and if let</a></li><li class="chapter-item "><a href="pattern-match/patterns.html"><strong aria-hidden="true">7.2.</strong> Patterns</a></li></ol></li><li class="chapter-item expanded "><a href="method.html"><strong aria-hidden="true">8.</strong> Method &amp; Associated function</a></li><li class="chapter-item expanded "><a href="generics-traits/intro.html"><strong aria-hidden="true">9.</strong> Generics and Traits todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics-traits/generics.html"><strong aria-hidden="true">9.1.</strong> Generics</a></li><li class="chapter-item "><a href="generics-traits/traits.html"><strong aria-hidden="true">9.2.</strong> Traits</a></li><li class="chapter-item "><a href="generics-traits/trait-object.html"><strong aria-hidden="true">9.3.</strong> Trait Object</a></li><li class="chapter-item "><a href="generics-traits/advance-traits.html"><strong aria-hidden="true">9.4.</strong> Advance Traits</a></li></ol></li><li class="chapter-item expanded "><a href="collections/intro.html"><strong aria-hidden="true">10.</strong> Collection Types todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="collections/vector.html"><strong aria-hidden="true">10.1.</strong> Vector</a></li><li class="chapter-item "><a href="collections/hashmap.html"><strong aria-hidden="true">10.2.</strong> HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="type-conversion.html"><strong aria-hidden="true">11.</strong> Type Conversion todo</a></li><li class="chapter-item expanded "><a href="result-panic/intro.html"><strong aria-hidden="true">12.</strong> Result and panic todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="result-panic/panic.html"><strong aria-hidden="true">12.1.</strong> panic!</a></li><li class="chapter-item "><a href="result-panic/result.html"><strong aria-hidden="true">12.2.</strong> result and ?</a></li></ol></li><li class="chapter-item expanded "><a href="crate-module/intro.html"><strong aria-hidden="true">13.</strong> Crate and module todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="crate-module/crate.html"><strong aria-hidden="true">13.1.</strong> Crate</a></li><li class="chapter-item "><a href="crate-module/module.html"><strong aria-hidden="true">13.2.</strong> Module</a></li><li class="chapter-item "><a href="crate-module/use-pub.html"><strong aria-hidden="true">13.3.</strong> use and pub</a></li></ol></li><li class="chapter-item expanded "><a href="comments-docs.html"><strong aria-hidden="true">14.</strong> Comments and Docs todo</a></li><li class="chapter-item expanded "><a href="formatted-output.html"><strong aria-hidden="true">15.</strong> Formatted output todo</a></li><li class="chapter-item expanded "><a href="lifetime/intro.html"><strong aria-hidden="true">16.</strong> Lifetime todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lifetime/basic.html"><strong aria-hidden="true">16.1.</strong> basic</a></li><li class="chapter-item "><a href="lifetime/static.html"><strong aria-hidden="true">16.2.</strong> &amp;'static and T: 'static</a></li><li class="chapter-item "><a href="lifetime/advance.html"><strong aria-hidden="true">16.3.</strong> advance</a></li></ol></li><li class="chapter-item expanded "><a href="functional-programing/intro.html"><strong aria-hidden="true">17.</strong> Functional programing todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="functional-programing/cloure.html"><strong aria-hidden="true">17.1.</strong> Closure</a></li><li class="chapter-item "><a href="functional-programing/iterator.html"><strong aria-hidden="true">17.2.</strong> Iterator</a></li></ol></li><li class="chapter-item expanded "><a href="newtype-sized.html"><strong aria-hidden="true">18.</strong> newtype and Sized todo</a></li><li class="chapter-item expanded "><a href="smart-pointers/intro.html"><strong aria-hidden="true">19.</strong> Smart pointers todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="smart-pointers/box.html"><strong aria-hidden="true">19.1.</strong> Box</a></li><li class="chapter-item "><a href="smart-pointers/deref.html"><strong aria-hidden="true">19.2.</strong> Deref</a></li><li class="chapter-item "><a href="smart-pointers/drop.html"><strong aria-hidden="true">19.3.</strong> Drop</a></li><li class="chapter-item "><a href="smart-pointers/rc-arc.html"><strong aria-hidden="true">19.4.</strong> Rc and Arc</a></li><li class="chapter-item "><a href="smart-pointers/cell-refcell.html"><strong aria-hidden="true">19.5.</strong> Cell and RefCell</a></li></ol></li><li class="chapter-item expanded "><a href="weak.html"><strong aria-hidden="true">20.</strong> Weak and Circle reference todo</a></li><li class="chapter-item expanded "><a href="self-referential.html"><strong aria-hidden="true">21.</strong> Self referential todo</a></li><li class="chapter-item expanded "><a href="threads/intro.html"><strong aria-hidden="true">22.</strong> Threads todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="threads/basic-using.html"><strong aria-hidden="true">22.1.</strong> Basic using</a></li><li class="chapter-item "><a href="threads/message-passing.html"><strong aria-hidden="true">22.2.</strong> Message passing</a></li><li class="chapter-item "><a href="threads/sync.html"><strong aria-hidden="true">22.3.</strong> Sync</a></li><li class="chapter-item "><a href="threads/atomic.html"><strong aria-hidden="true">22.4.</strong> Atomic</a></li><li class="chapter-item "><a href="threads/send-sync.html"><strong aria-hidden="true">22.5.</strong> Send and Sync</a></li></ol></li><li class="chapter-item expanded "><a href="global-variables.html"><strong aria-hidden="true">23.</strong> Global variables todo</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">24.</strong> Errors todo</a></li><li class="chapter-item expanded "><a href="unsafe/intro.html"><strong aria-hidden="true">25.</strong> Unsafe doing</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe/inline-asm.html"><strong aria-hidden="true">25.1.</strong> Inline assembly</a></li></ol></li><li class="chapter-item expanded "><a href="macro.html"><strong aria-hidden="true">26.</strong> Macro todo</a></li><li class="chapter-item expanded "><a href="tests/intro.html"><strong aria-hidden="true">27.</strong> Tests todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tests/write-tests.html"><strong aria-hidden="true">27.1.</strong> Write Tests</a></li><li class="chapter-item "><a href="tests/benchmark.html"><strong aria-hidden="true">27.2.</strong> Benchmark</a></li><li class="chapter-item "><a href="tests/unit-integration.html"><strong aria-hidden="true">27.3.</strong> Unit and Integration</a></li><li class="chapter-item "><a href="tests/assertions.html"><strong aria-hidden="true">27.4.</strong> Assertions</a></li></ol></li><li class="chapter-item expanded "><a href="async/intro.html"><strong aria-hidden="true">28.</strong> Async/Await todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="async/async-await.html"><strong aria-hidden="true">28.1.</strong> async and await!</a></li><li class="chapter-item "><a href="async/future.html"><strong aria-hidden="true">28.2.</strong> Future</a></li><li class="chapter-item "><a href="async/pin-unpin.html"><strong aria-hidden="true">28.3.</strong> Pin and Unpin</a></li><li class="chapter-item "><a href="async/stream.html"><strong aria-hidden="true">28.4.</strong> Stream</a></li></ol></li><li class="chapter-item expanded "><a href="std/intro.html"><strong aria-hidden="true">29.</strong> Stand Library todo</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust By Practice</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-by-practice" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-by-practice"><a class="header" href="#rust-by-practice">Rust By Practice</a></h1>
<p>This book was designed for easily diving into Rustï¼Œand it's very easy to use: All you need to do is to make each exercise comipile without ERRORS and Panics !</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li>There are three parts in each chapter: examples, exercises and practices</li>
<li>Covering nearly all aspects of Rust, such as <strong>async/await, threads, sync primitives, optimizing and stand libraries</strong> etc</li>
<li>Solution for each exercise</li>
<li>Difficulty from easy to super hard: easy ğŸŒŸ  medium ğŸŒŸğŸŒŸ hard ğŸŒŸğŸŒŸğŸŒŸ  super hard ğŸŒŸğŸŒŸğŸŒŸğŸŒŸ</li>
<li>Both <a href="https://practice.rs">English</a> and <a href="https://zh.practice.rs">Chinsese</a> are supported</li>
</ul>
<h2 id="some-of-our-exercises"><a class="header" href="#some-of-our-exercises">Some of our exercises</a></h2>
<p>ğŸŒŸğŸŒŸğŸŒŸ Tuple struct looks similar to tuples, it has added meaning the struct name provides but has no named fields. It's useful when you want give the whole tuple a name, but don't care the fields's names.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the error and fill the blanks
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
fn main() {
    let v = Point(___, ___, ___);
    check_color(v);
}   

fn check_color(p: Color) {
    let (x, _, _) = p;
    assert_eq!(x, 0);
    assert_eq!(p.1, 127);
    assert_eq!(___, 255);
 }
</code></pre></pre>
<p>ğŸŒŸğŸŒŸ Within the destructuring of a single variable, both by-move and by-reference pattern bindings can be used at the same time. Doing this will result in a partial move of the variable, which means that parts of the variable will be moved while other parts stay. In such a case, the parent variable cannot be used afterwards as a whole, however the parts that are only referenced (and not moved) can still be used.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix errors to make it work
#[derive(Debug)]
struct File {
    name: String,
    data: String,
}
fn main() {
    let f = File {
        name: String::from(&quot;readme.md&quot;),
        data: &quot;Rust By Practice&quot;.to_string()
    };

    let _name = f.name;

    // ONLY modify this line
    println!(&quot;{}, {}, {:?}&quot;,f.name, f.data, f);
} 
</code></pre></pre>
<p>ğŸŒŸğŸŒŸ A match guard is an additional if condition specified after the pattern in a match arm that must also match, along with the pattern matching, for that arm to be chosen.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blank to make the code work, `split` MUST be used
fn main() {
    let num = Some(4);
    let split = 5;
    match num {
        Some(x) __ =&gt; assert!(x &lt; split),
        Some(x) =&gt; assert!(x &gt;= split),
        None =&gt; (),
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<h3 id="binding-and-mutablity"><a class="header" href="#binding-and-mutablity">Binding and mutablity</a></h3>
<ol>
<li>ğŸŒŸ A variable can be used only if it has been initialized.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the error below with least modifying
fn main() {
    let x: i32; // uninitialized but using, ERROR !
    let y: i32; // uninitialized but also unusing, only warning
    println!(&quot;{} is equal to 5&quot;, x); 
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ Use <code>mut</code> to mark a variable as mutable.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blanks in code to make it compile
fn main() {
    let __ =  1;
    __ += 2; 
    
    println!(&quot;{} is equal to 3&quot;, x); 
}
</code></pre></pre>
<h3 id="scope"><a class="header" href="#scope">Scope</a></h3>
<p>A scope is the range within the program for which the item is valid.</p>
<ol start="3">
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable. edition2021">
// fix the error below with least modifying
fn main() {
    let x: i32 = 10;
    {
        let y: i32 = 5;
        println!(&quot;The value of x is {} and value of y is {}&quot;, x, y);
    }
    println!(&quot;The value of x is {} and value of y is {}&quot;, x, y); 
}
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the error with using of define_x
fn main() {
    println!(&quot;{}, world&quot;, x); 
}

fn define_x() {
    let x = &quot;hello&quot;;
}
</code></pre></pre>
<h3 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h3>
<p>You can declare a new variable with the same name as a previous variable, here we can say **the first one is shadowed by the second one.</p>
<ol start="5">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// only modify `assert_eq!` to make the `println!` work(print `42` in terminal)
fn main() {
    let x: i32 = 5;
    {
        let x = 12;
        assert_eq!(x, 5);
    }

    assert_eq!(x, 12);

    let x =  42;
    println!(&quot;{}&quot;, x); // Prints &quot;42&quot;.
}
</code></pre></pre>
<ol start="6">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// remove a line in code to make it compile
fn main() {
    let mut x: i32 = 1;
    x = 7;
    // shadowing and re-binding
    let x = x; 
    x += 3;


    let y = 4;
    // shadowing
    let y = &quot;I can also be bound to text!&quot;; 
}
</code></pre></pre>
<h3 id="unused-varibles"><a class="header" href="#unused-varibles">Unused varibles</a></h3>
<ol>
<li>fix the warning below with :</li>
</ol>
<ul>
<li>ğŸŒŸ  only one solution</li>
<li>ğŸŒŸğŸŒŸ  two distinct solutions</li>
</ul>
<blockquote>
<p>Note: none of the solutions is to remove the line <code>let x = 1</code> </p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let x = 1; 
}

// warning: unused variable: `x`
</code></pre></pre>
<h3 id="destructuring"><a class="header" href="#destructuring">Destructuring</a></h3>
<ol start="8">
<li>ğŸŒŸğŸŒŸ We can use a pattern with <code>let</code> to destructure a tuple to separate variables.</li>
</ol>
<blockquote>
<p>Tips: you can use Shadowing or Mutability</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the error below with least modifying
fn main() {
    let (x, y) = (1, 2);
    x += 2;

    assert_eq!(x, 3);
    assert_eq!(y, 2);
}
</code></pre></pre>
<h3 id="destructuring-assignments"><a class="header" href="#destructuring-assignments">Destructuring assignments</a></h3>
<p>Introducing in Rust 1.59: You can now use tuple, slice, and struct patterns as the left-hand side of an assignment.</p>
<ol start="9">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<blockquote>
<p>Note: the feature <code>Destructuring assignments</code> need 1.59 or higher Rust version</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let (x, y);
    (x,..) = (3, 4);
    [.., y] = [1, 2];
    // fill the blank to make the code work
    assert_eq!([x,y], __);
} 
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-types"><a class="header" href="#basic-types">Basic Types</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch03-02-data-types.html">Rust Book 3.2 and 3.3</a></li>
<li>ç®€ä½“ä¸­æ–‡: <a href="https://course.rs/basic/base-type/index.html">Rustè¯­è¨€åœ£ç» - åŸºæœ¬ç±»å‹</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numbers"><a class="header" href="#numbers">Numbers</a></h1>
<h3 id="integer"><a class="header" href="#integer">Integer</a></h3>
<ol>
<li>ğŸŒŸ </li>
</ol>
<blockquote>
<p>Tips: If we don't explicitly give one type to a varible, then the compiler will infer one for us</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// remove something to make it work
fn main() {
    let x: i32 = 5;
    let mut y: u32 = 5;

    y = x;
    
    let z = 10; // type of z ? 
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
//  fill the blank
fn main() {
    let v: u16 = 38_u8 as __;
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<blockquote>
<p>Tips: If we don't explicitly give one type to a varible, then the compiler will infer one for us</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// modify `assert_eq!` to make it work
fn main() {
    let x = 5;
    assert_eq!(&quot;u32&quot;.to_string(), type_of(&amp;x));
}

// get the type of given variable, return a string representation of the type  , e.g &quot;i8&quot;, &quot;u8&quot;, &quot;i32&quot;, &quot;u32&quot;
fn type_of&lt;T&gt;(_: &amp;T) -&gt; String {
    format!(&quot;{}&quot;, std::any::type_name::&lt;T&gt;())
}
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blanks to make it work
fn main() {
    assert_eq!(i8::MAX, __); 
    assert_eq!(u8::MAX, __); 
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix errors and panics to make it work
fn main() {
   let v1 = 251_u8 + 8;
   let v2 = i8::checked_add(251, 8).unwrap();
   println!(&quot;{},{}&quot;,v1,v2);
}
</code></pre></pre>
<ol start="6">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// modify `assert!` to make it work
fn main() {
    let v = 1_024 + 0xff + 0o77 + 0b1111_1111;
    assert!(v == 1579);
}
</code></pre></pre>
<h3 id="floating-point"><a class="header" href="#floating-point">Floating-Point</a></h3>
<ol start="7">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
//  replace ? with your answer
fn main() {
    let x = 1_000.000_1; // ?
    let y: f32 = 0.12; // f32
    let z = 0.01_f64; // f64
}
</code></pre></pre>
<ol>
<li>ğŸŒŸğŸŒŸ make it work in two distinct ways</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    assert!(0.1+0.2==0.3);
}
</code></pre></pre>
<h3 id="range"><a class="header" href="#range">Range</a></h3>
<ol start="9">
<li>ğŸŒŸğŸŒŸ two goals: 1. modify <code>assert!</code> to make it work 2. make <code>println!</code> output: 97 - 122</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut sum = 0;
    for i in -3..2 {
        sum += i
    }

    assert!(sum == -3);

    for c in 'a'..='z' {
        println!(&quot;{}&quot;,c);
    }
}
</code></pre></pre>
<ol start="10">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blanks
use std::ops::{Range, RangeInclusive};
fn main() {
    assert_eq!((1..__), Range{ start: 1, end: 5 });
    assert_eq!((1..__), RangeInclusive::new(1, 5));
}
</code></pre></pre>
<h3 id="computations"><a class="header" href="#computations">Computations</a></h3>
<ol start="11">
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blanks and fix the errors
fn main() {
    // Integer addition
    assert!(1u32 + 2 == __);

    // Integer subtraction
    assert!(1i32 - 2 == __);
    assert!(1u8 - 2 == -1); 
    
    assert!(3 * 50 == __);

    assert!(9.6 / 3.2 == 3.0); // error ! make it work

    assert!(24 % 5 == __);
    // Short-circuiting boolean logic
    assert!(true &amp;&amp; false == __);
    assert!(true || false == __);
    assert!(!true == __);

    // Bitwise operations
    println!(&quot;0011 AND 0101 is {:04b}&quot;, 0b0011u32 &amp; 0b0101);
    println!(&quot;0011 OR 0101 is {:04b}&quot;, 0b0011u32 | 0b0101);
    println!(&quot;0011 XOR 0101 is {:04b}&quot;, 0b0011u32 ^ 0b0101);
    println!(&quot;1 &lt;&lt; 5 is {}&quot;, 1u32 &lt;&lt; 5);
    println!(&quot;0x80 &gt;&gt; 2 is 0x{:x}&quot;, 0x80u32 &gt;&gt; 2);
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="char-bool-and-unit"><a class="header" href="#char-bool-and-unit">Char, Bool and Unit</a></h1>
<h3 id="char"><a class="header" href="#char">Char</a></h3>
<ol>
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
// make it work
use std::mem::size_of_val;
fn main() {
    let c1 = 'a';
    assert_eq!(size_of_val(&amp;c1),1); 

    let c2 = 'ä¸­';
    assert_eq!(size_of_val(&amp;c2),3); 
} 
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
// make it work
fn main() {
    let c1 = &quot;ä¸­&quot;;
    print_char(c1);
} 

fn print_char(c : char) {
    println!(&quot;{}&quot;, c);
}
</code></pre></pre>
<h3 id="bool"><a class="header" href="#bool">Bool</a></h3>
<ol start="3">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
// make the println! work
fn main() {
    let _f: bool = false;

    let t = true;
    if !t {
        println!(&quot;hello, world&quot;);
    }
} 
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
// make it work
fn main() {
    let f = true;
    let t = true &amp;&amp; false;
    assert_eq!(t, f);
}
</code></pre></pre>
<h3 id="unit-type"><a class="header" href="#unit-type">Unit type</a></h3>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// make it work, don't modify `implicitly_ret_unit` !
fn main() {
    let _v: () = ();

    let v = (2, 3);
    assert_eq!(v, implicitly_ret_unit())
}

fn implicitly_ret_unit() {
    println!(&quot;I will returen a ()&quot;)
}

// don't use this one
fn explicitly_ret_unit() -&gt; () {
    println!(&quot;I will returen a ()&quot;)
}
</code></pre></pre>
<ol start="6">
<li>ğŸŒŸğŸŒŸ what's the size of the unit type?</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// modify `4` in assert to make it work
use std::mem::size_of_val;
fn main() {
    let unit: () = ();
    assert!(size_of_val(&amp;unit) == 4);
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="statements-and-expressions"><a class="header" href="#statements-and-expressions">Statements and Expressions</a></h1>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 5u32;

    let y = {
        let x_squared = x * x;
        let x_cube = x_squared * x;

        // This expression will be assigned to `y`
        x_cube + x_squared + x
    };

    let z = {
        // The semicolon suppresses this expression and `()` is assigned to `z`
        2 * x;
    };

    println!(&quot;x is {:?}&quot;, x);
    println!(&quot;y is {:?}&quot;, y);
    println!(&quot;z is {:?}&quot;, z);
}
</code></pre></pre>
<h3 id="exercises"><a class="header" href="#exercises">Exercises</a></h3>
<ol>
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// make it work with two ways
fn main() {
   let v = {
       let mut x = 1;
       x += 2
   };

   assert_eq!(v, 3);
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   let v = (let x = 3);

   assert!(v == 3);
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = sum(1 , 2);
    assert_eq!(s, 3);
}

fn sum(x: i32, y: i32) -&gt; i32 {
    x + y;
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<ol>
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // don't modify the following two lines!
    let (x, y) = (1, 2);
    let s = sum(x, y);

    assert_eq!(s, 3);
}

fn sum(x, y: i32) {
    x + y;
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
   print();
}

// replace i32 with another type
fn print() -&gt; i32 {
   println!(&quot;hello,world&quot;);
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// solve it in two ways
fn main() {
    never_return();
}

fn never_return() -&gt; ! {
    // implement this function, don't modify the fn signatures
    
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-and-borrowing"><a class="header" href="#ownership-and-borrowing">Ownership and Borrowing</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">Rust Book 4.1-4.4</a></li>
<li>ç®€ä½“ä¸­æ–‡: [Rustè¯­è¨€åœ£ç» - æ‰€æœ‰æƒä¸å€Ÿç”¨(https://course.rs/basic/ownership/index.html)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<ol>
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // use as many approaches as you can to make it work
    let x = String::from(&quot;hello, world&quot;);
    let y = x;
    println!(&quot;{},{}&quot;,x,y);
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Don't modify code in main!
fn main() {
    let s1 = String::from(&quot;hello, world&quot;);
    let s2 = take_ownership(s1);

    println!(&quot;{}&quot;, s2);
}

// Only modify the code below!
fn take_ownership(s: String) {
    println!(&quot;{}&quot;, s);
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = give_ownership();
    println!(&quot;{}&quot;, s);
}

// Only modify the code below!
fn give_ownership() -&gt; String {
    let s = String::from(&quot;hello, world&quot;);
    // convert String to Vec
    let _s = s.into_bytes();
    s
}
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// fix the error without removing code line
fn main() {
    let s = String::from(&quot;hello, world&quot;);

    print_str(s);

    println!(&quot;{}&quot;, s);
}

fn print_str(s: String)  {
    println!(&quot;{}&quot;,s)
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">// don't use clone ,use copy instead
fn main() {
    let x = (1, 2, (), &quot;hello&quot;.to_string());
    let y = x.clone();
    println!(&quot;{:?}, {:?}&quot;, x, y);
}
</code></pre></pre>
<h4 id="mutability"><a class="header" href="#mutability">Mutability</a></h4>
<p>Mutability can be changed when ownership is transferred.</p>
<ol start="6">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = String::from(&quot;hello, &quot;);
    
    // modify this line only !
    let s1 = s;

    s1.push_str(&quot;world&quot;)
}
</code></pre></pre>
<ol start="7">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let x = Box::new(5);
    
    let ...      // implement this line, dont change other lines!
    
    *y = 4;
    
    assert_eq!(*x, 5);
}
</code></pre></pre>
<h3 id="partial-move"><a class="header" href="#partial-move">Partial move</a></h3>
<p>Within the destructuring of a single variable, both by-move and by-reference pattern bindings can be used at the same time. Doing this will result in a partial move of the variable, which means that parts of the variable will be moved while other parts stay. In such a case, the parent variable cannot be used afterwards as a whole, however the parts that are only referenced (and not moved) can still be used.</p>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    #[derive(Debug)]
    struct Person {
        name: String,
        age: Box&lt;u8&gt;,
    }

    let person = Person {
        name: String::from(&quot;Alice&quot;),
        age: Box::new(20),
    };

    // `name` is moved out of person, but `age` is referenced
    let Person { name, ref age } = person;

    println!(&quot;The person's age is {}&quot;, age);

    println!(&quot;The person's name is {}&quot;, name);

    // Error! borrow of partially moved value: `person` partial move occurs
    //println!(&quot;The person struct is {:?}&quot;, person);

    // `person` cannot be used but `person.age` can be used as it is not moved
    println!(&quot;The person's age from person struct is {}&quot;, person.age);
}
</code></pre></pre>
<h4 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h4>
<ol start="8">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;));

   let _s = t.0;

   // modify this line only, don't use `_s`
   println!(&quot;{:?}&quot;, t);
}
</code></pre></pre>
<ol start="9">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;));

    // fill the blanks
    let (__, __) = __;

    println!(&quot;{:?}, {:?}, {:?}&quot;, s1, s2, t); // -&gt; &quot;hello&quot;, &quot;world&quot;, (&quot;hello&quot;, &quot;world&quot;)
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-and-borrowing"><a class="header" href="#reference-and-borrowing">Reference and Borrowing</a></h1>
<h3 id="reference"><a class="header" href="#reference">Reference</a></h3>
<ol>
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   let x = 5;
   // fill the blank
   let p = __;

   println!(&quot;the memory address of x is {:p}&quot;, p); // one possible output: 0x16fa3ac84
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let x = 5;
    let y = &amp;x;

    // modify this line only
    assert_eq!(5, y);
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix error
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    borrow_object(s)
}

fn borrow_object(s: &amp;String) {}
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix error
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    push_str(s)
}

fn push_str(s: &amp;mut String) {
    s.push_str(&quot;world&quot;)
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    // fill the blank to make it work
    let p = __;
    
    p.push_str(&quot;world&quot;);
}
</code></pre></pre>
<h4 id="ref"><a class="header" href="#ref">ref</a></h4>
<p><code>ref</code> can be used to take references to a value, similar to <code>&amp;</code>.</p>
<ol start="6">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let c = 'ä¸­';

    let r1 = &amp;c;
    // fill the blankï¼Œdont change other code
    let __ r2 = c;

    assert_eq!(*r1, *r2);
    
    // check the equality of the two address strings
    assert_eq!(get_addr(r1),get_addr(r2));
}

// get memory address string
fn get_addr(r: &amp;char) -&gt; String {
    format!(&quot;{:p}&quot;, r)
}
</code></pre></pre>
<h3 id="borrowing-rules"><a class="header" href="#borrowing-rules">Borrowing rules</a></h3>
<ol start="7">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// remove something to make it work
// don't remove a whole line !
fn main() {
    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
}
</code></pre></pre>
<h4 id="mutablity"><a class="header" href="#mutablity">Mutablity</a></h4>
<ol start="8">
<li>ğŸŒŸ Error: Borrow a immutable object as mutable</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    //fix error by modifying this line
    let  s = String::from(&quot;hello, &quot;);

    borrow_object(&amp;mut s)
}

fn borrow_object(s: &amp;mut String) {}
</code></pre></pre>
<ol start="9">
<li>ğŸŒŸğŸŒŸ Ok: Borrow a mutable object as immutable</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// this code has no errors!
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    borrow_object(&amp;s);
    
    s.push_str(&quot;world&quot;);
}

fn borrow_object(s: &amp;String) {}
</code></pre></pre>
<h3 id="nll"><a class="header" href="#nll">NLL</a></h3>
<ol start="10">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// comment one line to make it work
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    let r1 = &amp;mut s;
    r1.push_str(&quot;world&quot;);
    let r2 = &amp;mut s;
    r2.push_str(&quot;!&quot;);
    
    println!(&quot;{}&quot;,r1);
}
</code></pre></pre>
<ol start="11">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    // add one line below to make a compiler error: cannot borrow `s` as mutable more than once at a time
    // you can't use r1 and r2 at the same time
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch04-03-slices.html">Rust Book 4.3, 5.1, 6.1, 8.2</a></li>
<li>ç®€ä½“ä¸­æ–‡: <a href="https://course.rs/basic/compound-type/intro.html">Rustè¯­è¨€åœ£ç» - å¤åˆç±»å‹</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">string</a></h1>
<p>The type of string literal <code>&quot;hello, world&quot;</code> is <code>&amp;str</code>, e.g <code>let s: &amp;str = &quot;hello, world&quot;</code>.</p>
<h3 id="str-and-str"><a class="header" href="#str-and-str">str and &amp;str</a></h3>
<ol>
<li>ğŸŒŸ We can't use <code>str</code> type in normal ways, but we can use <code>&amp;str</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix error without adding new line
fn main() {
   let s: str = &quot;hello, world&quot;;
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ We can only use <code>str</code> by boxed it, <code>&amp;</code> can be used to convert <code>Box&lt;str&gt;</code> to <code>&amp;str</code> </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the error with at least two solutions
fn main() {
   let s: Box&lt;str&gt; =  &quot;hello, world&quot;.into();
   greetings(s)
}

fn greetings(s: &amp;str) {
    println!(&quot;{}&quot;,s)
}
</code></pre></pre>
<h3 id="string-1"><a class="header" href="#string-1">String</a></h3>
<p><code>String</code> type is defined in std and stored as a vector of bytes (Vec<u8>), but guaranteed to always be a valid UTF-8 sequence. String is heap allocated, growable and not null terminated.</p>
<ol start="3">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blank
fn main() {
   let mut s = __;
   s.push_str(&quot;hello, world&quot;);
   s.push('!');

   assert_eq!(s, &quot;hello, world!&quot;);
}
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix all errors without adding newline
fn main() {
   let  s =  String::from(&quot;hello&quot;);
    s.push(',');
    s.push(&quot; world&quot;);
    s += &quot;!&quot;.to_string();

    println!(&quot;{}&quot;, s)
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ <code>replace</code> can be used to replace substring</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blank
fn main() {
   let s = String::from(&quot;I like dogs&quot;);
   // Allocate new memory and store the modified string there
   let s1 = s.__(&quot;dogs&quot;, &quot;cats&quot;);

   assert_eq!(s1, &quot;I like cats&quot;)
}
</code></pre></pre>
<p>More <code>String</code> methods can be found under <a href="https://doc.rust-lang.org/std/string/struct.String.html">String</a> module.</p>
<ol start="6">
<li>ğŸŒŸğŸŒŸ You can only concat a <code>String</code> with <code>&amp;str</code>, and <code>String</code>'s ownership can be moved to another variable</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix errors without removing any line
fn main() {
    let s1 = String::from(&quot;hello,&quot;);
    let s2 = String::from(&quot;world!&quot;);
    let s3 = s1 + s2; 
    assert_eq!(s3,&quot;hello,world!&quot;);
    println!(&quot;{}&quot;,s1);
}
</code></pre></pre>
<h3 id="str-and-string"><a class="header" href="#str-and-string">&amp;str and String</a></h3>
<p>Opsite to the seldom using of <code>str</code>, <code>&amp;str</code> and <code>String</code> are used everywhere!</p>
<ol start="7">
<li>ğŸŒŸğŸŒŸ <code>&amp;str</code> can be converted to <code>String</code> in two ways</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix error with at lest two solutions
fn main() {
   let s =  &quot;hello, world&quot;;
   greetings(s)
}

fn greetings(s: String) {
    println!(&quot;{}&quot;,s)
}
</code></pre></pre>
<ol start="8">
<li>ğŸŒŸğŸŒŸ We can use <code>String::from</code> or <code>to_string</code> to convert a <code>&amp;str</code> to <code>String</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// use two approaches to fix the error and without adding a new line
fn main() {
   let s =  &quot;hello, world&quot;.to_string();
   let s1: &amp;str = s;
}
</code></pre></pre>
<h3 id="string-escapes"><a class="header" href="#string-escapes">string escapes</a></h3>
<ol start="9">
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // You can use escapes to write bytes by their hexadecimal values
    // fill the blank below to show &quot;I'm writing Rust&quot;
    let byte_escape = &quot;I'm writing Ru\x73__!&quot;;
    println!(&quot;What are you doing\x3F (\\x3F means ?) {}&quot;, byte_escape);

    // ...or Unicode code points.
    let unicode_codepoint = &quot;\u{211D}&quot;;
    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;

    println!(&quot;Unicode character {} (U+211D) is called {}&quot;,
                unicode_codepoint, character_name );

   let long_string = &quot;String literals
                        can span multiple lines.
                        The linebreak and indentation here \
                         can be escaped too!&quot;;
    println!(&quot;{}&quot;, long_string);
}
</code></pre></pre>
<ol start="10">
<li>ğŸŒŸğŸŒŸğŸŒŸ Sometimes there are just too many characters that need to be escaped or it's just much more convenient to write a string out as-is. This is where raw string literals come into play.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let raw_str = r&quot;Escapes don't work here: \x3F \u{211D}&quot;;
    // modify below line to make it work
    assert_eq!(raw_str, &quot;Escapes don't work here: ? â„&quot;);

    // If you need quotes in a raw string, add a pair of #s
    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;
    println!(&quot;{}&quot;, quotes);

    // If you need &quot;# in your string, just use more #s in the delimiter.
    // You can use up to 65535 #s.
    let  delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;
    println!(&quot;{}&quot;, delimiter);

    // fill the blank
    let long_delimiter = __;
    assert_eq!(long_delimiter, &quot;Hello, \&quot;##\&quot;&quot;)
}
</code></pre></pre>
<h3 id="byte-string"><a class="header" href="#byte-string">byte string</a></h3>
<p>Want a string that's not UTF-8? (Remember, str and String must be valid UTF-8). Or maybe you want an array of bytes that's mostly text? Byte strings to the rescue!</p>
<p><strong>Example</strong>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::str;

fn main() {
    // Note that this is not actually a `&amp;str`
    let bytestring: &amp;[u8; 21] = b&quot;this is a byte string&quot;;

    // Byte arrays don't have the `Display` trait, so printing them is a bit limited
    println!(&quot;A byte string: {:?}&quot;, bytestring);

    // Byte strings can have byte escapes...
    let escaped = b&quot;\x52\x75\x73\x74 as bytes&quot;;
    // ...but no unicode escapes
    // let escaped = b&quot;\u{211D} is not allowed&quot;;
    println!(&quot;Some escaped bytes: {:?}&quot;, escaped);


    // Raw byte strings work just like raw strings
    let raw_bytestring = br&quot;\u{211D} is not escaped here&quot;;
    println!(&quot;{:?}&quot;, raw_bytestring);

    // Converting a byte array to `str` can fail
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!(&quot;And the same as text: '{}'&quot;, my_str);
    }

    let _quotes = br#&quot;You can also use &quot;fancier&quot; formatting, \
                    like with normal raw strings&quot;#;

    // Byte strings don't have to be UTF-8
    let shift_jis = b&quot;\x82\xe6\x82\xa8\x82\xb1\x82\xbb&quot;; // &quot;ã‚ˆã†ã“ã&quot; in SHIFT-JIS

    // But then they can't always be converted to `str`
    match str::from_utf8(shift_jis) {
        Ok(my_str) =&gt; println!(&quot;Conversion successful: '{}'&quot;, my_str),
        Err(e) =&gt; println!(&quot;Conversion failed: {:?}&quot;, e),
    };
}
</code></pre></pre>
<p>A more detailed listing of the ways to write string literals and escape characters is given in the <a href="https://doc.rust-lang.org/reference/tokens.html">'Tokens' chapter</a> of the Rust Reference.</p>
<h3 id="string-index"><a class="header" href="#string-index">string index</a></h3>
<ol start="11">
<li>ğŸŒŸğŸŒŸğŸŒŸ You can't use index to access a char in a string, but you can use slice <code>&amp;s1[start..end]</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s1 = String::from(&quot;hi,ä¸­å›½&quot;);
    let h = s1[0]; //modify this line to fix the error, tips: `h` only takes 1 byte in UTF8 format
    assert_eq!(h, &quot;h&quot;);

    let h1 = &amp;s1[3..5];//modify this line to fix the error, tips: `ä¸­`  takes 3 bytes in UTF8 format
    assert_eq!(h1, &quot;ä¸­&quot;);
}
</code></pre></pre>
<h3 id="operate-on-utf8-string"><a class="header" href="#operate-on-utf8-string">operate on UTF8 string</a></h3>
<ol start="12">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // fill the blank to print each char in &quot;ä½ å¥½ï¼Œä¸–ç•Œ&quot;
    for c in &quot;ä½ å¥½ï¼Œä¸–ç•Œ&quot;.__ {
        println!(&quot;{}&quot;, c)
    }
}
</code></pre></pre>
<h4 id="utf8_slice"><a class="header" href="#utf8_slice">utf8_slice</a></h4>
<p>You can use <a href="https://docs.rs/utf8_slice/1.0.0/utf8_slice/fn.slice.html">utf8_slice</a> to slice UTF8 string, it can index chars instead of bytes.</p>
<p><strong>Example</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">use utf_slice;
fn main() {
   let s = &quot;The ğŸš€ goes to the ğŸŒ‘!&quot;;

   let rocket = utf8_slice::slice(s, 4, 5);
   // Will equal &quot;ğŸš€&quot;
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array"><a class="header" href="#array">Array</a></h1>
<p>The type of array is <code>[T; Lengh]</code>, as you can see, array's lengh is part of their type signature. So their length must be known at compile time.</p>
<p>For example, you cant initialized an array as below:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init_arr(n: i32) {
    let arr = [1; n];
}
<span class="boring">}
</span></code></pre></pre>
<p>This will cause an error, because the compile have no idea of the exact size of the array in compile time.</p>
<ol>
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // fill the blank with proper array type
    let arr: __ = [1, 2, 3, 4, 5];

    // modify below to make it work
    assert!(arr.len() == 4);
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // we can ignore parts of the array type or even the whole type, let the compiler infer it for us
    let arr0 = [1, 2, 3];
    let arr: [_; 3] = ['a', 'b', 'c'];
    
    // fill the blank
    // Arrays are stack allocated, `std::mem::size_of_val` return the bytes which array occupies
    // A char takes 4 byte in Rust: Unicode char
    assert!(std::mem::size_of_val(&amp;arr) == __);
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸ All elements in an array can be initialized to the same value at once.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // fill the blank
    let list: [i32; 100] = __ ;

    assert!(list[0] == 1);
    assert!(list.len() == 100);
}
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸ All elements in an array must be of the same type</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // fix the error
    let _arr = [1, 2, '3'];
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸ Indexing starts at 0.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let arr = ['a', 'b', 'c'];
    
    let ele = arr[1]; // only modify this line to make the code work!

    assert!(ele == 'a');
}
</code></pre></pre>
<ol start="6">
<li>ğŸŒŸ Out of bounds indexing causes <code>panic</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the error
fn main() {
    let names = [String::from(&quot;Sunfei&quot;), &quot;Sunface&quot;.to_string()];
    
    // `get` returns an Option&lt;T&gt;, it's safe to use
    let name0 = names.get(0).unwrap();

    // but indexing is not safe
    let _name1 = &amp;names[2];
}

</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slice"><a class="header" href="#slice">Slice</a></h1>
<p>Slices are similar to arrays, but their length is not known at compile time, so you can't use slice directly.</p>
<ol>
<li>ğŸŒŸğŸŒŸ Here, both <code>[i32]</code> and <code>str</code> are slice types, but directly using it will cause errors. You have to use the reference of the slice instead: <code>&amp;[i32]</code>, <code>&amp;str</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the errors, DON'T add new lines!
fn main() {
    let arr = [1, 2, 3];
    let s1: [i32] = arr[0..2];

    let s2: str = &quot;hello, world&quot; as str;
}
</code></pre></pre>
<p>A slice reference is a two-word object, for simplicity reasons, from now on we will use slice instead of <code>slice reference</code>.  The first word is a pointer to the data, and the second word is the length of the slice. The word size is the same as usize, determined by the processor architecture eg 64 bits on an x86-64. Slices can be used to borrow a section of an array, and have the type signature <code>&amp;[T]</code>.</p>
<ol start="2">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let arr: [char; 3] = ['ä¸­', 'å›½', 'äºº'];

    let slice = &amp;arr[..2];
    
    // modify '6' to make it work
    // TIPS: slice( reference ) IS NOT an array, if it is an array, then `assert!` will passed: each of the two UTF-8 chars 'ä¸­' and 'å›½'  occupies 3 bytes, 2 * 3 = 6
    assert!(std::mem::size_of_val(&amp;slice) == 6);
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
  let arr: [i32; 5] = [1, 2, 3, 4, 5];
  // fill the blanks to make the code work
  let slice: __ = __;
  assert_eq!(slice, &amp;[2, 3, 4]);
}
</code></pre></pre>
<h3 id="string-slices"><a class="header" href="#string-slices">string slices</a></h3>
<ol start="4">
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = String::from(&quot;hello&quot;);

    let slice1 = &amp;s[0..2];
    // fill the blank to make the code work, DON'T USE 0..2 again
    let slice2 = &amp;s[__];

    assert_eq!(slice1, slice2);
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = &quot;ä½ å¥½ï¼Œä¸–ç•Œ&quot;;
    // modify this line to make the code work
    let slice = &amp;s[0..2];

    assert!(slice == &quot;ä½ &quot;);
}
</code></pre></pre>
<ol start="6">
<li>ğŸŒŸğŸŒŸ <code>&amp;String</code> can be implicitly converted into <code>&amp;str</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix errors
fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    // here, &amp;s is `&amp;String` type, but `first_word` need a `&amp;str` type.
    // it works because `&amp;String` can be implicitly converted to `&amp;str, If you want know more ,this is called `Deref` 
    let word = first_word(&amp;s);

    s.clear(); // error!

    println!(&quot;the first word is: {}&quot;, word);
}
fn first_word(s: &amp;str) -&gt; &amp;str {
    &amp;s[..1]
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuple"><a class="header" href="#tuple">Tuple</a></h1>
<ol>
<li>ğŸŒŸ Elements in a tuple can have different types. Tuple's type signature is <code>(T1, T2, ...)</code>, where <code>T1</code>, <code>T2</code> are the types of tuple's members.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let _t0: (u8,i16) = (0, -1);
    // Tuples can be tuple's members
    let _t1: (u8, (i16, u32)) = (0, (-1, 1));
    // fill the blanks to make the code work
    let t: (u8, __, i64, __, __) = (1u8, 2u16, 3i64, &quot;hello&quot;, String::from(&quot;, world&quot;));
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ Members can be extracted from the tuple using indexing.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// make it works
fn main() {
   let t = (&quot;i&quot;, &quot;am&quot;, &quot;sunface&quot;);
   assert_eq!(t.1, &quot;sunface&quot;);
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸ Long tuples  cannot be printed</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the error
fn main() {
    let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    println!(&quot;too long tuple: {:?}&quot;, too_long_tuple);
}
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸ Destructuring tuple with pattern.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let tup = (1, 6.4, &quot;hello&quot;);

    // fill the blank to make the code work
    let __ = tup;

    assert_eq!(x, 1);
    assert_eq!(y, &quot;hello&quot;);
    assert_eq!(z, 6.4);
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ Destructure assignments.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let (x, y, z);

    // fill the blank
    __ = (1, 2, 3);
    
    assert_eq!(x, 3);
    assert_eq!(y, 1);
    assert_eq!(z, 2);
}
</code></pre></pre>
<ol start="6">
<li>ğŸŒŸğŸŒŸ Tuples can be used as function arguments and return values</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   // fill the blank, need a few computations here.
   let (x, y) = sum_multiply(__);

   assert_eq!(x, 5);
   assert_eq!(y, 6);
}

fn sum_multiply(nums: (i32, i32)) -&gt; (i32, i32) {
    (nums.0 + nums.1, nums.0 * nums.1)
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct"><a class="header" href="#struct">Struct</a></h1>
<h3 id="there-types-of-structs"><a class="header" href="#there-types-of-structs">There types of structs</a></h3>
<ol>
<li>ğŸŒŸ We must specify concrete values for each of the fields in struct.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the error
struct Person {
    name: String,
    age: u8,
    hobby: String
}
fn main() {
    let age = 30;
    let p = Person {
        name: String::from(&quot;sunface&quot;),
        age,
    };
} 
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ Unit struct don't have any fields. It can be useful when you need to implement a trait on some type but donâ€™t have any data that you want to store in the type itself. </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Unit;
trait SomeTrait {
    // ...Some behavours defines here
}

// We don't care the the fields are in Unit, but we care its behaviors.
// So we use a struct with no fields and implement some behaviors for it
impl SomeTrait for Unit {  }
fn main() {
    let u = Unit;
    do_something_with_unit(u);
} 

// fill the blank to make the code work
fn do_something_with_unit(u: __) {   }
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸğŸŒŸ Tuple struct looks similar to tuples, it has added meaning the struct name provides but has no named fields. It's useful when you want give the whole tuple a name, but don't care the fields's names.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the error and fill the blanks
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
fn main() {
    let v = Point(__, __, __);
    check_color(v);
}   

fn check_color(p: Color) {
    let (x, _, _) = p;
    assert_eq!(x, 0);
    assert_eq!(p.1, 127);
    assert_eq!(__, 255);
 }
</code></pre></pre>
<h3 id="operate-on-structs"><a class="header" href="#operate-on-structs">Operate on structs</a></h3>
<ol start="4">
<li>ğŸŒŸ You can make a whole struct mutable when instantiate it, but Rust doesn't allow us to mark only certain fields as mutable.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blank and fix the error without adding/removing new line
struct Person {
    name: String,
    age: u8,
}
fn main() {
    let age = 18;
    let p = Person {
        name: String::from(&quot;sunface&quot;),
        age,
    };

    // how can you believe sunface is only 18? 
    p.age = 30;

    // fill the lank
    __ = String::from(&quot;sunfei&quot;);
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸ Using <em>field init shorthand syntax</em> to reduct repetitions.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blank
struct Person {
    name: String,
    age: u8,
}
fn main() {} 

fn build_person(name: String, age: u8) -&gt; Person {
    Person {
        age,
        __
    }
}
</code></pre></pre>
<ol start="6">
<li>ğŸŒŸ You can create instance from other instance with <em>struct update syntax</em></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blank to make the code work
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
fn main() {
    let u1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;sunface&quot;),
        active: true,
        sign_in_count: 1,
    };

    let u2 = set_email(u1);
} 

fn set_email(u: User) -&gt; User {
    User {
        email: String::from(&quot;contact@im.dev&quot;),
        __
    }
}
</code></pre></pre>
<h3 id="print-the-structs"><a class="header" href="#print-the-structs">Print the structs</a></h3>
<ol start="7">
<li>ğŸŒŸğŸŒŸ We can use <code>#[derive(Debug)]</code> to <a href="https://doc.rust-lang.org/book/ch05-02-example-structs.html?highlight=%23%5Bderive(Debug)%5D#adding-useful-functionality-with-derived-traits">make a struct prinable</a>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blanks to make the code work
#[__]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale), // print debug info to stderr and assign the value of  `30 * scale` to `width`
        height: 50,
    };

    dbg!(&amp;rect1); // print debug info to stderr

    println!(__, rect1); // print debug info to stdout
}
</code></pre></pre>
<h3 id="partial-move-1"><a class="header" href="#partial-move-1">Partial move</a></h3>
<p>Within the destructuring of a single variable, both by-move and by-reference pattern bindings can be used at the same time. Doing this will result in a partial move of the variable, which means that parts of the variable will be moved while other parts stay. In such a case, the parent variable cannot be used afterwards as a whole, however the parts that are only referenced (and not moved) can still be used.</p>
<h4 id="example-1"><a class="header" href="#example-1">Example</a></h4>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    #[derive(Debug)]
    struct Person {
        name: String,
        age: Box&lt;u8&gt;,
    }

    let person = Person {
        name: String::from(&quot;Alice&quot;),
        age: Box::new(20),
    };

    // `name` is moved out of person, but `age` is referenced
    let Person { name, ref age } = person;

    println!(&quot;The person's age is {}&quot;, age);

    println!(&quot;The person's name is {}&quot;, name);

    // Error! borrow of partially moved value: `person` partial move occurs
    //println!(&quot;The person struct is {:?}&quot;, person);

    // `person` cannot be used but `person.age` can be used as it is not moved
    println!(&quot;The person's age from person struct is {}&quot;, person.age);
}
</code></pre></pre>
<h4 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h4>
<ol start="8">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix errors to make it work
#[derive(Debug)]
struct File {
    name: String,
    data: String,
}
fn main() {
    let f = File {
        name: String::from(&quot;readme.md&quot;),
        data: &quot;Rust By Practice&quot;.to_string()
    };

    let _name = f.name;

    // ONLY modify this line
    println!(&quot;{}, {}, {:?}&quot;,f.name, f.data, f);
} 
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum"><a class="header" href="#enum">Enum</a></h1>
<ol>
<li>ğŸŒŸğŸŒŸ Enums can be created with explicit discriminator.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the errors
enum Number {
    Zero,
    One,
    Two,
}

enum Number1 {
    Zero = 0,
    One,
    Two,
}

// C-like enum
enum Number2 {
    Zero = 0.0,
    One = 1.0,
    Two = 2.0,
}


fn main() {
    // a enum variant can be converted to a integer by `as`
    assert_eq!(Number::One, Number1::One);
    assert_eq!(Number1::One, Number2::One);
} 
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ each enum variant can hold its own data.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blank
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg1 = Message::Move{__}; // instantiating with x = 1, y = 2 
    let msg2 = Message::Write(__); // instantiating with &quot;hello, world!&quot;
} 
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ we can get the data which a enum variant is holding by pattern match</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blank and fix the error
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::Move{x: 1, y: 2};

    if let Message::Move{__} = msg {
        assert_eq!(a, b);
    } else {
        panic!(&quot;NEVER LET THIS RUNï¼&quot;);
    }
} 
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blank and fix the errors
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msgs: __ = [
        Message::Quit,
        Message::Move{x:1, y:3},
        Message::ChangeColor(255,255,0)
    ];

    for msg in msgs {
        show_message(msg)
    }
} 

fn show_message(msg: Message) {
    println!(&quot;{}&quot;, msg);
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ As there is no <code>null</code> in Rust, we have to use enum  <code>Option&lt;T&gt;</code>  to deal the cases when value is absent.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blank to make the `println` work.
// also add some code to prevent the `panic` from running.
fn main() {
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

    if let __ = six {
        println!(&quot;{}&quot;, n)
    } 
        
    panic!(&quot;NEVER LET THIS RUNï¼&quot;);
} 

fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        __ =&gt; None,
        __ =&gt; Some(i + 1),
    }
}
</code></pre></pre>
<ol start="6">
<li>ğŸŒŸğŸŒŸğŸŒŸğŸŒŸ implement a <code>linked-list</code> via enums.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use crate::List::*;

enum List {
    // Cons: Tuple struct that wraps an element and a pointer to the next node
    Cons(u32, Box&lt;List&gt;),
    // Nil: A node that signifies the end of the linked list
    Nil,
}

// Methods can be attached to an enum
impl List {
    // Create an empty list
    fn new() -&gt; List {
        // `Nil` has type `List`
        Nil
    }

    // Consume a list, and return the same list with a new element at its front
    fn prepend(self, elem: u32) -&gt; __ {
        // `Cons` also has type List
        Cons(elem, Box::new(self))
    }

    // Return the length of the list
    fn len(&amp;self) -&gt; u32 {
        // `self` has to be matched, because the behavior of this method
        // depends on the variant of `self`
        // `self` has type `&amp;List`, and `*self` has type `List`, matching on a
        // concrete type `T` is preferred over a match on a reference `&amp;T`
        // after Rust 2018 you can use self here and tail (with no ref) below as well,
        // rust will infer &amp;s and ref tail. 
        // See https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/default-match-bindings.html
        match *self {
            // Can't take ownership of the tail, because `self` is borrowed;
            // instead take a reference to the tail
            Cons(_, ref tail) =&gt; 1 + tail.len(),
            // Base Case: An empty list has zero length
            Nil =&gt; 0
        }
    }

    // Return representation of the list as a (heap allocated) string
    fn stringify(&amp;self) -&gt; String {
        match *self {
            Cons(head, __ tail) =&gt; {
                // `format!` is similar to `print!`, but returns a heap
                // allocated string instead of printing to the console
                format!(&quot;{}, {}&quot;, head, tail.__())
            },
            Nil =&gt; {
                format!(&quot;Nil&quot;)
            },
        }
    }
}

fn main() {
    // Create an empty linked list
    let mut list = List::new();

    // Prepend some elements
    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    // Show the final state of the list
    println!(&quot;linked list has length: {}&quot;, list.len());
    println!(&quot;{}&quot;, list.stringify());
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flow-control"><a class="header" href="#flow-control">Flow control</a></h1>
<h3 id="ifelse"><a class="header" href="#ifelse">if/else</a></h3>
<ol>
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blanks
fn main() {
    let n = 5;

    if n &lt; 0 {
        println!(&quot;{} is negative&quot;, n);
    } __ n &gt; 0 {
        println!(&quot;{} is positive&quot;, n);
    } __ {
        println!(&quot;{} is zero&quot;, n);
    }
} 
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ <code>if/else</code> expression can be used in assignments.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the errors
fn main() {
    let n = 5;

    let big_n =
        if n &lt; 10 &amp;&amp; n &gt; -10 {
            println!(&quot;, and is a small number, increase ten-fold&quot;);

            10 * n
        } else {
            println!(&quot;, and is a big number, halve the number&quot;);

            n / 2.0 ;
        }

    println!(&quot;{} -&gt; {}&quot;, n, big_n);
} 
</code></pre></pre>
<h3 id="for"><a class="header" href="#for">for</a></h3>
<ol start="3">
<li>ğŸŒŸ The <code>for in</code> construct can be used to iterate through an Iterator, e.g a range <code>a..b</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    for n in 1..=100 { // modify this line to make the code work
        if n == 100 {
            panic!(&quot;NEVER LET THIS RUN&quot;)
        }
    }
} 
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the errors without adding or removing lines
fn main() {
    let names = [String::from(&quot;liming&quot;),String::from(&quot;hanmeimei&quot;)];
    for name in names {
        // do something with name...
    }

    println!(&quot;{:?}&quot;, names);

    let numbers = [1, 2, 3];
    // the elements in numbers are Copyï¼Œso there is no move here
    for n in numbers {
        // do something with name...
    }
    
    println!(&quot;{:?}&quot;, numbers);
} 
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let a = [4, 3, 2, 1];

    // iterate the indexing and value in 'a'
    for (i,v) in a.__ {
        println!(&quot;The {}th element is {}&quot;,i+1,v);
    }
}
</code></pre></pre>
<h3 id="while"><a class="header" href="#while">while</a></h3>
<ol start="6">
<li>ğŸŒŸğŸŒŸ The <code>while</code> keyword can be used to run a loop when a condition is true.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blanks to make the last println! work !
fn main() {
    // A counter variable
    let mut n = 1;

    // Loop while the condition is true
    while n __ 10 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }


        __;
    }

    println!(&quot;n reached {}, soloop is over&quot;,n);
}
</code></pre></pre>
<h3 id="continue-and-break"><a class="header" href="#continue-and-break">continue and break</a></h3>
<ol start="7">
<li>ğŸŒŸ use <code>break</code> to break the loop.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blank
fn main() {
    let mut n = 0;
    for i in 0..=100 {
       if n == 66 {
           __
       }
       n += 1;
    }

    assert_eq!(n, 66);
}
</code></pre></pre>
<ol start="8">
<li>ğŸŒŸğŸŒŸ <code>continue</code> will skip over the remaining code in current iteration and go to the next iteration.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blanks
fn main() {
    let mut n = 0;
    for i in 0..=100 {
       if n != 66 {
           n+=1;
           __;
       }
       
       __
    }

    assert_eq!(n, 66);
}
</code></pre></pre>
<h3 id="loop"><a class="header" href="#loop">loop</a></h3>
<ol start="9">
<li>ğŸŒŸğŸŒŸ loop is usually used together with <code>break</code> or <code>continue</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blanks
fn main() {
    let mut count = 0u32;

    println!(&quot;Let's count until infinity!&quot;);

    // Infinite loop
    loop {
        count += 1;

        if count == 3 {
            println!(&quot;three&quot;);

            // Skip the rest of this iteration
            __;
        }

        println!(&quot;{}&quot;, count);

        if count == 5 {
            println!(&quot;OK, that's enough&quot;);

            __;
        }
    }

    assert_eq!(count, 5);
}
</code></pre></pre>
<ol start="10">
<li>ğŸŒŸğŸŒŸ loop is an expression, so we can use it with <code>break</code> to return a value</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blank
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            __;
        }
    };

    assert_eq!(result, 20);
}
</code></pre></pre>
<ol start="11">
<li>ğŸŒŸğŸŒŸğŸŒŸ It's possible to break or continue outer loops when dealing with nested loops. In these cases, the loops must be annotated with some 'label, and the label must be passed to the break/continue statement.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blank
fn main() {
    let mut count = 0;
    'outer: loop {
        'inner1: loop {
            if count &gt;= 20 {
                // This would break only the inner1 loop
                break 'inner1; // `break` is also ok 
            }
            count += 2;
        }

        count += 5;

        'inner2: loop {
            if count &gt;= 30 {
                // This breaks the outer loop
                break 'outer;
            }

            // This will continue the outer loop
            continue 'outer;
        }
    }

    assert!(count == __)
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-match"><a class="header" href="#pattern-match">Pattern Match</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch18-00-patterns.html">Rust Book 18</a></li>
<li>ç®€ä½“ä¸­æ–‡: <a href="https://course.rs/basic/match-pattern/intro.html">Rustè¯­è¨€åœ£ç» - æ¨¡å¼åŒ¹é…</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-if-let"><a class="header" href="#match-if-let">match, if let</a></h1>
<h3 id="match"><a class="header" href="#match">match</a></h3>
<ol>
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blanks
enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East =&gt; println!(&quot;East&quot;),
        __  =&gt; { // matching South or North here
            println!(&quot;South or North&quot;);
        },
        _ =&gt; println!(__),
    };
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ match is an expression, so we can use it in assignments</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let boolean = true;

    // fill the blank with an match expression:
    //
    // boolean = true =&gt; binary = 1
    // boolean = false =&gt;  binary = 0
    let binary = __;

    assert_eq!(binary, 1);
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ using match to get the data an enum variant holds</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blanks
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msgs = [
        Message::Quit,
        Message::Move{x:1, y:3},
        Message::ChangeColor(255,255,0)
    ];

    for msg in msgs {
        show_message(msg)
    }
} 

fn show_message(msg: Message) {
    match msg {
        __ =&gt; { // match  Message::Move
            assert_eq!(a, 1);
            assert_eq!(b, 3);
        },
        Message::ChangeColor(_, g, b) =&gt; {
            assert_eq!(g, __);
            assert_eq!(b, __);
        }
        __ =&gt; println!(&quot;no data in these variants&quot;)
    }
}
</code></pre></pre>
<h3 id="matches"><a class="header" href="#matches">matches!</a></h3>
<p><a href="https://doc.rust-lang.org/stable/core/macro.matches.html"><code>matches!</code></a> looks like <code>match</code>, but can do something different</p>
<ol start="4">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let alphabets = ['a', 'E', 'Z', '0', 'x', '9' , 'Y'];

    // fill the blank with `matches!` to make the code work
    for ab in alphabets {
        assert!(__)
    }
} 
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
enum MyEnum {
    Foo,
    Bar
}

fn main() {
    let mut count = 0;

    let v = vec![MyEnum::Foo,MyEnum::Bar,MyEnum::Foo];
    for e in v {
        if e == MyEnum::Foo { // fix the error with changing only this line
            count += 1;
        }
    }

    assert_eq!(count, 2);
}
</code></pre></pre>
<h3 id="if-let"><a class="header" href="#if-let">if let</a></h3>
<p>For some cases, when matching enums, <code>match</code> is too heavy, we can use <code>if let</code> instead.</p>
<ol start="6">
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let o = Some(7);

    // remove the whole `match` block, using `if let` instead 
    match o {
        Some(i) =&gt; {
            println!(&quot;This is a really long string and `{:?}`&quot;, i);
        }
        _ =&gt; {}
    };
}
</code></pre></pre>
<ol start="7">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blank
enum Foo {
    Bar(u8)
}

fn main() {
    let a = Foo::Bar(1);

    __ {
        println!(&quot;foobar holds the value: {}&quot;, i);
    }
}
</code></pre></pre>
<ol start="8">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
enum Foo {
    Bar,
    Baz,
    Qux(u32)
}

fn main() {
    let a = Foo::Qux(10);

    // remove the codes below, using `match` instead 
    if let Foo::Bar = a {
        println!(&quot;match foo::bar&quot;)
    } else if let Foo::Baz = a {
        println!(&quot;match foo::baz&quot;)
    } else {
        println!(&quot;match others&quot;)
    }
}
</code></pre></pre>
<h3 id="shadowing-1"><a class="header" href="#shadowing-1">Shadowing</a></h3>
<ol start="9">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the errors in-place
fn main() {
    let age = Some(30);
    if let Some(age) = age { // create a new variable with the same name as previous `age`
       assert_eq!(age, Some(30));
    } // the new variable `age` goes out of scope here
    
    match age {
        // match can also introduce a new shadowed variable
        Some(age) =&gt;  println!(&quot;age is a new variable, it's value is {}&quot;,age),
        _ =&gt; ()
    }
 }
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patterns"><a class="header" href="#patterns">Patterns</a></h1>
<ol>
<li>ğŸŒŸğŸŒŸ use <code>|</code> to match several values, use <code>..=</code> to match a inclusive range</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {}
fn match_number(n: i32) {
    match n {
        // match a single value
        1 =&gt; println!(&quot;One!&quot;),
        // fill in the blank with `|`, DON'T use `..` ofr `..=`
        __ =&gt; println!(&quot;match 2 -&gt; 5&quot;),
        // match an inclusive range
        6..=10 =&gt; {
            println!(&quot;match 6 -&gt; 10&quot;)
        },
        _ =&gt; {
            println!(&quot;match 11 -&gt; +infinite&quot;)
        }
    }
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸğŸŒŸ The <code>@</code> operator lets us create a variable that holds a value at the same time we are testing that value to see whether it matches a pattern.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    // fill in the blank to let p match the second arm
    let p = Point { x: __, y: __ };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        // second arm
        Point { x: 0..=5, y: y@ (10 | 20 | 30) } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the errors
enum Message {
    Hello { id: i32 },
}

fn main() {
    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id:  3..=7,
        } =&gt; println!(&quot;Found an id in range [3, 7]: {}&quot;, id),
        Message::Hello { id: newid@10 | 11 | 12 } =&gt; {
            println!(&quot;Found an id in another range [10, 12]: {}&quot;, newid)
        }
        Message::Hello { id } =&gt; println!(&quot;Found some other id: {}&quot;, id),
    }
}
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ A match guard is an additional if condition specified after the pattern in a match arm that must also match, along with the pattern matching, for that arm to be chosen.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blank to make the code work, `split` MUST be used
fn main() {
    let num = Some(4);
    let split = 5;
    match num {
        Some(x) __ =&gt; assert!(x &lt; split),
        Some(x) =&gt; assert!(x &gt;= split),
        None =&gt; (),
    }
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ Ignoring remaining parts of the value with <code>..</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blank to make the code work
fn main() {
    let numbers = (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048);

    match numbers {
        __ =&gt; {
           assert_eq!(first, 2);
           assert_eq!(last, 2048);
        }
    }
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="associated-function--method"><a class="header" href="#associated-function--method">Associated function &amp; Method</a></h1>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Point {
    x: f64,
    y: f64,
}

// Implementation block, all `Point` associated functions &amp; methods go in here
impl Point {
    // This is an &quot;associated function&quot; because this function is associated with
    // a particular type, that is, Point.
    //
    // Associated functions don't need to be called with an instance.
    // These functions are generally used like constructors.
    fn origin() -&gt; Point {
        Point { x: 0.0, y: 0.0 }
    }

    // Another associated function, taking two arguments:
    fn new(x: f64, y: f64) -&gt; Point {
        Point { x: x, y: y }
    }
}

struct Rectangle {
    p1: Point,
    p2: Point,
}

impl Rectangle {
    // This is a method
    // `&amp;self` is sugar for `self: &amp;Self`, where `Self` is the type of the
    // caller object. In this case `Self` = `Rectangle`
    fn area(&amp;self) -&gt; f64 {
        // `self` gives access to the struct fields via the dot operator
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        // `abs` is a `f64` method that returns the absolute value of the
        // caller
        ((x1 - x2) * (y1 - y2)).abs()
    }

    fn perimeter(&amp;self) -&gt; f64 {
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        2.0 * ((x1 - x2).abs() + (y1 - y2).abs())
    }

    // This method requires the caller object to be mutable
    // `&amp;mut self` desugars to `self: &amp;mut Self`
    fn translate(&amp;mut self, x: f64, y: f64) {
        self.p1.x += x;
        self.p2.x += x;

        self.p1.y += y;
        self.p2.y += y;
    }
}

// `Pair` owns resources: two heap allocated integers
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

impl Pair {
    // This method &quot;consumes&quot; the resources of the caller object
    // `self` desugars to `self: Self`
    fn destroy(self) {
        // Destructure `self`
        let Pair(first, second) = self;

        println!(&quot;Destroying Pair({}, {})&quot;, first, second);

        // `first` and `second` go out of scope and get freed
    }
}

fn main() {
    let rectangle = Rectangle {
        // Associated functions are called using double colons
        p1: Point::origin(),
        p2: Point::new(3.0, 4.0),
    };

    // Methods are called using the dot operator
    // Note that the first argument `&amp;self` is implicitly passed, i.e.
    // `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)`
    println!(&quot;Rectangle perimeter: {}&quot;, rectangle.perimeter());
    println!(&quot;Rectangle area: {}&quot;, rectangle.area());

    let mut square = Rectangle {
        p1: Point::origin(),
        p2: Point::new(1.0, 1.0),
    };

    // Error! `rectangle` is immutable, but this method requires a mutable
    // object
    //rectangle.translate(1.0, 0.0);
    // TODO ^ Try uncommenting this line

    // Okay! Mutable objects can call mutable methods
    square.translate(1.0, 1.0);

    let pair = Pair(Box::new(1), Box::new(2));

    pair.destroy();

    // Error! Previous `destroy` call &quot;consumed&quot; `pair`
    //pair.destroy();
    // TODO ^ Try uncommenting this line
}
</code></pre></pre>
<h2 id="exercises-3"><a class="header" href="#exercises-3">Exercises</a></h2>
<h3 id="method"><a class="header" href="#method">Method</a></h3>
<ol>
<li>ğŸŒŸğŸŒŸ Methods are similar to functions: declare with <code>fn</code>, have parameters and a return value.  Unlike functions, methods are defined within the context of a struct (or an enum or a trait object), and their first parameter is always <code>self</code>, which represents the instance of the struct the method is being called on.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // complete the area method which return the area of a Rectangle
    fn area
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    assert_eq!(rect1.area(), 1500);
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ <code>self</code> will take the ownership of current struct instance, however, <code>&amp;self</code> will only borrow a reference from the instance</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Only fill in the blanks, DON'T remove any line!
#[derive(Debug)]
struct TrafficLight {
    color: String,
}

impl TrafficLight {
    pub fn show_state(__)  {
        println!(&quot;the current state is {}&quot;, __.color);
    }
}
fn main() {
    let light = TrafficLight{
        color: &quot;red&quot;.to_owned(),
    };
    // Don't take the ownership of `light` here
    light.show_state();
    // ..otherwise, there will be an error below
    println!(&quot;{:?}&quot;, light);
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ The <code>&amp;self</code> is actually short for <code>self: &amp;Self</code>. Within an <code>impl</code> block, the type <code>Self</code> is an alias for the type that the <code>impl</code> block is for. Methods must have a parameter named <code>self</code> of type <code>Self</code> for their first parameter, so Rust lets you abbreviate this with only the name <code>self</code> in the first parameter spot. </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct TrafficLight {
    color: String,
}

impl TrafficLight {
    // using `Self` to fill in the blank
    pub fn show_state(__)  {
        println!(&quot;the current state is {}&quot;, self.color);
    }

    // fill in the blank, DON'T use any variants of `Self`
    pub fn change_state() {
        self.color = &quot;green&quot;.to_string()
    }
}
fn main() {}
</code></pre></pre>
<h3 id="associated-function"><a class="header" href="#associated-function">Associated function</a></h3>
<ol start="4">
<li>ğŸŒŸğŸŒŸ  All functions defined within an <code>impl</code> block are called associated functions because theyâ€™re associated with the type named after the <code>impl</code>. We can define associated functions that donâ€™t have <code>self</code> as their first parameter (and thus are not methods) because they donâ€™t need an instance of the type to work with.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct TrafficLight {
    color: String,
}

impl TrafficLight {
    // 1. implement a assotiated function `new`,
    // 2. it will return a TrafficLight contains color &quot;red&quot;
    // 3. must use `Self`, DONT use `TrafficLight`
    pub fn new() 

    pub fn get_state(&amp;self) -&gt; &amp;str {
        &amp;self.color
    }
}

fn main() {
    let light = TrafficLight::new();
    assert_eq!(light.get_state(), &quot;red&quot;);
}
</code></pre></pre>
<h3 id="multiple-impl-blocks"><a class="header" href="#multiple-impl-blocks">Multiple <code>impl</code> blocks</a></h3>
<ol start="5">
<li>ğŸŒŸ Each struct is allowed to have multiple impl blocks. </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Rectangle {
    width: u32,
    height: u32,
}

// rewrite Rectangle to use multiple `impl` blocks
impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}


fn main() {}
</code></pre></pre>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<ol start="6">
<li>ğŸŒŸğŸŒŸğŸŒŸ We can also implement methods for enums.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
#[derive(Debug)]
enum TrafficLightColor {
    Red,
    Yellow,
    Green,
}

// implement TrafficLightColor with a method
impl TrafficLightColor {
    
}

fn main() {
    let c = TrafficLightColor::Yellow;

    assert_eq!(c.color(), &quot;yellow&quot;);

    println!(&quot;{:?}&quot;,c);
}
</code></pre></pre>
<h2 id="practice"><a class="header" href="#practice">Practice</a></h2>
<p>@todo</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-and-traits"><a class="header" href="#generics-and-traits">Generics and Traits</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-object"><a class="header" href="#trait-object">Trait Object</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advance-traits"><a class="header" href="#advance-traits">Advance Traits</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collection-types"><a class="header" href="#collection-types">Collection Types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector"><a class="header" href="#vector">Vector</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-conversion"><a class="header" href="#type-conversion">Type Conversion</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-and-panic"><a class="header" href="#result-and-panic">Result and panic</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic"><a class="header" href="#panic">panic!</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-and-"><a class="header" href="#result-and-">result and ?</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crate-and-module"><a class="header" href="#crate-and-module">Crate and module</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crate"><a class="header" href="#crate">Crate</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="module"><a class="header" href="#module">Module</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-and-pub"><a class="header" href="#use-and-pub">use and pub</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments-and-docs"><a class="header" href="#comments-and-docs">Comments and Docs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatted-output"><a class="header" href="#formatted-output">Formatted output</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetime"><a class="header" href="#lifetime">Lifetime</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤"><a class="header" href="#ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤">ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print(s: &amp;str);                                      // elided
fn print&lt;'a&gt;(s: &amp;'a str);                               // expanded

fn debug(lvl: usize, s: &amp;str);                          // elided
fn debug&lt;'a&gt;(lvl: usize, s: &amp;'a str);                   // expanded

fn substr(s: &amp;str, until: usize) -&gt; &amp;str;               // elided
fn substr&lt;'a&gt;(s: &amp;'a str, until: usize) -&gt; &amp;'a str;     // expanded

fn get_str() -&gt; &amp;str;                                   // ILLEGAL

fn frob(s: &amp;str, t: &amp;str) -&gt; &amp;str;                      // ILLEGAL

fn get_mut(&amp;mut self) -&gt; &amp;mut T;                        // elided
fn get_mut&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut T;              // expanded

fn args&lt;T: ToCStr&gt;(&amp;mut self, args: &amp;[T]) -&gt; &amp;mut Command                  // elided
fn args&lt;'a, 'b, T: ToCStr&gt;(&amp;'a mut self, args: &amp;'b [T]) -&gt; &amp;'a mut Command // expanded

fn new(buf: &amp;mut [u8]) -&gt; BufWriter;                    // elided
fn new(buf: &amp;mut [u8]) -&gt; BufWriter&lt;'_&gt;;                // elided (with `rust_2018_idioms`)
fn new&lt;'a&gt;(buf: &amp;'a mut [u8]) -&gt; BufWriter&lt;'a&gt;          // expanded
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-and-t-static"><a class="header" href="#static-and-t-static">&amp;'static and T: 'static</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Display;

fn main() {
  let mut string = &quot;First&quot;.to_owned();

  string.push_str(string.to_uppercase().as_str());
  print_a(&amp;string);
  print_b(&amp;string);
  print_c(&amp;string); // Compilation error
  print_d(&amp;string); // Compilation error
  print_e(&amp;string);
  print_f(&amp;string);
  print_g(&amp;string); // Compilation error
}

fn print_a&lt;T: Display + 'static&gt;(t: &amp;T) {
  println!(&quot;{}&quot;, t);
}

fn print_b&lt;T&gt;(t: &amp;T)
where
  T: Display + 'static,
{
  println!(&quot;{}&quot;, t);
}

fn print_c(t: &amp;'static dyn Display) {
  println!(&quot;{}&quot;, t)
}

fn print_d(t: &amp;'static impl Display) {
  println!(&quot;{}&quot;, t)
}

fn print_e(t: &amp;(dyn Display + 'static)) {
  println!(&quot;{}&quot;, t)
}

fn print_f(t: &amp;(impl Display + 'static)) {
  println!(&quot;{}&quot;, t)
}

fn print_g(t: &amp;'static String) {
  println!(&quot;{}&quot;, t);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advance"><a class="header" href="#advance">advance</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-programing"><a class="header" href="#functional-programing">Functional programing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closure"><a class="header" href="#closure">Closure</a></h1>
<p>ä¸‹é¢ä»£ç æ˜¯Ruståœ£ç»è¯¾ç¨‹ä¸­<a href="http://course.rs/advance/functional-programing/closure.html#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85">é—­åŒ…</a>ç« èŠ‚çš„è¯¾å†…ç»ƒä¹ é¢˜ç­”æ¡ˆï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Cacher&lt;T,E&gt;
where
    T: Fn(E) -&gt; E,
    E: Copy
{
    query: T,
    value: Option&lt;E&gt;,
}

impl&lt;T,E&gt; Cacher&lt;T,E&gt;
where
    T: Fn(E) -&gt; E,
    E: Copy
{
    fn new(query: T) -&gt; Cacher&lt;T,E&gt; {
        Cacher {
            query,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: E) -&gt; E {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.query)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}
fn main() {
  
}

#[test]
fn call_with_different_values() {
    let mut c = Cacher::new(|a| a);

    let v1 = c.value(1);
    let v2 = c.value(2);

    assert_eq!(v2, 1);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterator"><a class="header" href="#iterator">Iterator</a></h1>
<p>https://doc.rust-lang.org/stable/rust-by-example/flow_control/for.html#for-and-iterators</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// (all the type annotations are superfluous)
// A reference to a string allocated in read only memory
let pangram: &amp;'static str = &quot;the quick brown fox jumps over the lazy dog&quot;;
println!(&quot;Pangram: {}&quot;, pangram);

// Iterate over words in reverse, no new string is allocated
println!(&quot;Words in reverse&quot;);
for word in pangram.split_whitespace().rev() {
    println!(&quot;&gt; {}&quot;, word);
}

// Copy chars into a vector, sort and remove duplicates
let mut chars: Vec&lt;char&gt; = pangram.chars().collect();
chars.sort();
chars.dedup();
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="newtype-and-sized"><a class="header" href="#newtype-and-sized">newtype and Sized</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointers"><a class="header" href="#smart-pointers">Smart pointers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box"><a class="header" href="#box">Box</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deref"><a class="header" href="#deref">Deref</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drop"><a class="header" href="#drop">Drop</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rc-and-arc"><a class="header" href="#rc-and-arc">Rc and Arc</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cell-and-refcell"><a class="header" href="#cell-and-refcell">Cell and RefCell</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="weak-and-circle-reference"><a class="header" href="#weak-and-circle-reference">Weak and Circle reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="self-referential"><a class="header" href="#self-referential">Self referential</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threads"><a class="header" href="#threads">Threads</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-using"><a class="header" href="#basic-using">Basic using</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-passing"><a class="header" href="#message-passing">Message passing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sync"><a class="header" href="#sync">Sync</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic"><a class="header" href="#atomic">Atomic</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-and-sync"><a class="header" href="#send-and-sync">Send and Sync</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-variables"><a class="header" href="#global-variables">Global variables</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errors"><a class="header" href="#errors">Errors</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-todo"><a class="header" href="#unsafe-todo">Unsafe todo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-assembly"><a class="header" href="#inline-assembly">Inline assembly</a></h1>
<p>Rust provides support for inline assembly via the <code>asm!</code> macro.
It can be used to embed handwritten assembly in the assembly output generated by the compiler.
Generally this should not be necessary, but might be where the required performance or timing
cannot be otherwise achieved. Accessing low level hardware primitives, e.g. in kernel code, may also demand this functionality.</p>
<blockquote>
<p><strong>Note</strong>: the examples here are given in x86/x86-64 assembly, but other architectures are also supported.</p>
</blockquote>
<p>Inline assembly is currently supported on the following architectures:</p>
<ul>
<li>x86 and x86-64</li>
<li>ARM</li>
<li>AArch64</li>
<li>RISC-V</li>
</ul>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic usage</a></h2>
<p>Let us start with the simplest possible example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

unsafe {
    asm!(&quot;nop&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>This will insert a NOP (no operation) instruction into the assembly generated by the compiler.
Note that all <code>asm!</code> invocations have to be inside an <code>unsafe</code> block, as they could insert
arbitrary instructions and break various invariants. The instructions to be inserted are listed
in the first argument of the <code>asm!</code> macro as a string literal.</p>
<h2 id="inputs-and-outputs"><a class="header" href="#inputs-and-outputs">Inputs and outputs</a></h2>
<p>Now inserting an instruction that does nothing is rather boring. Let us do something that
actually acts on data:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let x: u64;
unsafe {
    asm!(&quot;mov {}, 5&quot;, out(reg) x);
}
assert_eq!(x, 5);
<span class="boring">}
</span></code></pre></pre>
<p>This will write the value <code>5</code> into the <code>u64</code> variable <code>x</code>.
You can see that the string literal we use to specify instructions is actually a template string.
It is governed by the same rules as Rust <a href="https://doc.rust-lang.org/std/fmt/#syntax">format strings</a>.
The arguments that are inserted into the template however look a bit different than you may
be familiar with. First we need to specify if the variable is an input or an output of the
inline assembly. In this case it is an output. We declared this by writing <code>out</code>.
We also need to specify in what kind of register the assembly expects the variable.
In this case we put it in an arbitrary general purpose register by specifying <code>reg</code>.
The compiler will choose an appropriate register to insert into
the template and will read the variable from there after the inline assembly finishes executing.</p>
<p>Let us see another example that also uses an input:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let i: u64 = 3;
let o: u64;
unsafe {
    asm!(
        &quot;mov {0}, {1}&quot;,
        &quot;add {0}, 5&quot;,
        out(reg) o,
        in(reg) i,
    );
}
assert_eq!(o, 8);
<span class="boring">}
</span></code></pre></pre>
<p>This will add <code>5</code> to the input in variable <code>i</code> and write the result to variable <code>o</code>.
The particular way this assembly does this is first copying the value from <code>i</code> to the output,
and then adding <code>5</code> to it.</p>
<p>The example shows a few things:</p>
<p>First, we can see that <code>asm!</code> allows multiple template string arguments; each
one is treated as a separate line of assembly code, as if they were all joined
together with newlines between them. This makes it easy to format assembly
code.</p>
<p>Second, we can see that inputs are declared by writing <code>in</code> instead of <code>out</code>.</p>
<p>Third, we can see that we can specify an argument number, or name as in any format string.
For inline assembly templates this is particularly useful as arguments are often used more than once.
For more complex inline assembly using this facility is generally recommended, as it improves
readability, and allows reordering instructions without changing the argument order.</p>
<p>We can further refine the above example to avoid the <code>mov</code> instruction:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut x: u64 = 3;
unsafe {
    asm!(&quot;add {0}, 5&quot;, inout(reg) x);
}
assert_eq!(x, 8);
<span class="boring">}
</span></code></pre></pre>
<p>We can see that <code>inout</code> is used to specify an argument that is both input and output.
This is different from specifying an input and output separately in that it is guaranteed to assign both to the same register.</p>
<p>It is also possible to specify different variables for the input and output parts of an <code>inout</code> operand:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let x: u64 = 3;
let y: u64;
unsafe {
    asm!(&quot;add {0}, 5&quot;, inout(reg) x =&gt; y);
}
assert_eq!(y, 8);
<span class="boring">}
</span></code></pre></pre>
<h2 id="late-output-operands"><a class="header" href="#late-output-operands">Late output operands</a></h2>
<p>The Rust compiler is conservative with its allocation of operands. It is assumed that an <code>out</code>
can be written at any time, and can therefore not share its location with any other argument.
However, to guarantee optimal performance it is important to use as few registers as possible,
so they won't have to be saved and reloaded around the inline assembly block.
To achieve this Rust provides a <code>lateout</code> specifier. This can be used on any output that is
written only after all inputs have been consumed.
There is also a <code>inlateout</code> variant of this specifier.</p>
<p>Here is an example where <code>inlateout</code> <em>cannot</em> be used:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
let c: u64 = 4;
unsafe {
    asm!(
        &quot;add {0}, {1}&quot;,
        &quot;add {0}, {2}&quot;,
        inout(reg) a,
        in(reg) b,
        in(reg) c,
    );
}
assert_eq!(a, 12);
<span class="boring">}
</span></code></pre></pre>
<p>Here the compiler is free to allocate the same register for inputs <code>b</code> and <code>c</code> since it knows they have the same value. However it must allocate a separate register for <code>a</code> since it uses <code>inout</code> and not <code>inlateout</code>. If <code>inlateout</code> was used, then <code>a</code> and <code>c</code> could be allocated to the same register, in which case the first instruction to overwrite the value of <code>c</code> and cause the assembly code to produce the wrong result.</p>
<p>However the following example can use <code>inlateout</code> since the output is only modified after all input registers have been read:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
unsafe {
    asm!(&quot;add {0}, {1}&quot;, inlateout(reg) a, in(reg) b);
}
assert_eq!(a, 8);
<span class="boring">}
</span></code></pre></pre>
<p>As you can see, this assembly fragment will still work correctly if <code>a</code> and <code>b</code> are assigned to the same register.</p>
<h2 id="explicit-register-operands"><a class="header" href="#explicit-register-operands">Explicit register operands</a></h2>
<p>Some instructions require that the operands be in a specific register.
Therefore, Rust inline assembly provides some more specific constraint specifiers.
While <code>reg</code> is generally available on any architecture, explicit registers are highly architecture specific. E.g. for x86 the general purpose registers <code>eax</code>, <code>ebx</code>, <code>ecx</code>, <code>edx</code>, <code>ebp</code>, <code>esi</code>, and <code>edi</code> among others can be addressed by their name.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let cmd = 0xd1;
unsafe {
    asm!(&quot;out 0x64, eax&quot;, in(&quot;eax&quot;) cmd);
}
<span class="boring">}
</span></code></pre></pre>
<p>In this example we call the <code>out</code> instruction to output the content of the <code>cmd</code> variable to port <code>0x64</code>. Since the <code>out</code> instruction only accepts <code>eax</code> (and its sub registers) as operand we had to use the <code>eax</code> constraint specifier.</p>
<blockquote>
<p><strong>Note</strong>: unlike other operand types, explicit register operands cannot be used in the template string: you can't use <code>{}</code> and should write the register name directly instead. Also, they must appear at the end of the operand list after all other operand types.</p>
</blockquote>
<p>Consider this example which uses the x86 <code>mul</code> instruction:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

fn mul(a: u64, b: u64) -&gt; u128 {
    let lo: u64;
    let hi: u64;

    unsafe {
        asm!(
            // The x86 mul instruction takes rax as an implicit input and writes
            // the 128-bit result of the multiplication to rax:rdx.
            &quot;mul {}&quot;,
            in(reg) a,
            inlateout(&quot;rax&quot;) b =&gt; lo,
            lateout(&quot;rdx&quot;) hi
        );
    }

    ((hi as u128) &lt;&lt; 64) + lo as u128
}
<span class="boring">}
</span></code></pre></pre>
<p>This uses the <code>mul</code> instruction to multiply two 64-bit inputs with a 128-bit result.
The only explicit operand is a register, that we fill from the variable <code>a</code>.
The second operand is implicit, and must be the <code>rax</code> register, which we fill from the variable <code>b</code>.
The lower 64 bits of the result are stored in <code>rax</code> from which we fill the variable <code>lo</code>.
The higher 64 bits are stored in <code>rdx</code> from which we fill the variable <code>hi</code>.</p>
<h2 id="clobbered-registers"><a class="header" href="#clobbered-registers">Clobbered registers</a></h2>
<p>In many cases inline assembly will modify state that is not needed as an output.
Usually this is either because we have to use a scratch register in the assembly or because instructions modify state that we don't need to further examine.
This state is generally referred to as being &quot;clobbered&quot;.
We need to tell the compiler about this since it may need to save and restore this state around the inline assembly block.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use core::arch::asm;

fn main() {
    // three entries of four bytes each
    let mut name_buf = [0_u8; 12];
    // String is stored as ascii in ebx, edx, ecx in order
    // Because ebx is reserved, we get a scratch register and move from
    // ebx into it in the asm.  The asm needs to preserve the value of
    // that register though, so it is pushed and popped around the main asm
    // (in 64 bit mode for 64 bit processors, 32 bit processors would use ebx)

    unsafe {
        asm!(
            &quot;push rbx&quot;,
            &quot;cpuid&quot;,
            &quot;mov [{0}], ebx&quot;,
            &quot;mov [{0} + 4], edx&quot;,
            &quot;mov [{0} + 8], ecx&quot;,
            &quot;pop rbx&quot;,
            // We use a pointer to an array for storing the values to simplify
            // the Rust code at the cost of a couple more asm instructions
            // This is more explicit with how the asm works however, as opposed
            // to explicit register outputs such as `out(&quot;ecx&quot;) val`
            // The *pointer itself* is only an input even though it's written behind
            in(reg) name_buf.as_mut_ptr(),
            // select cpuid 0, also specify eax as clobbered
            inout(&quot;eax&quot;) 0 =&gt; _,
            // cpuid clobbers these registers too
            out(&quot;ecx&quot;) _,
            out(&quot;edx&quot;) _,
        );
    }

    let name = core::str::from_utf8(&amp;name_buf).unwrap();
    println!(&quot;CPU Manufacturer ID: {}&quot;, name);
}
</code></pre></pre>
<p>In the example above we use the <code>cpuid</code> instruction to read the CPU manufacturer ID.
This instruction writes to <code>eax</code> with the maximum supported <code>cpuid</code> argument and <code>ebx</code>, <code>esx</code>, and <code>ecx</code> with the CPU manufacturer ID as ASCII bytes in that order.</p>
<p>Even though <code>eax</code> is never read we still need to tell the compiler that the register has been modified so that the compiler can save any values that were in these registers before the asm. This is done by declaring it as an output but with <code>_</code> instead of a variable name, which indicates that the output value is to be discarded.</p>
<p>This code also works around the limitation that <code>ebx</code> is a reserved register by LLVM. That means that LLVM assumes that it has full control over the register and it must be restored to its original state before exiting the asm block, so it cannot be used as an output. To work around this we save the register via <code>push</code>, read from <code>ebx</code> inside the asm block into a temporary register allocated with <code>out(reg)</code> and then restoring <code>ebx</code> to its original state via <code>pop</code>. The <code>push</code> and <code>pop</code> use the full 64-bit <code>rbx</code> version of the register to ensure that the entire register is saved. On 32 bit targets the code would instead use <code>ebx</code> in the <code>push</code>/<code>pop</code>.</p>
<p>This can also be used with a general register class (e.g. <code>reg</code>) to obtain a scratch register for use inside the asm code:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

// Multiply x by 6 using shifts and adds
let mut x: u64 = 4;
unsafe {
    asm!(
        &quot;mov {tmp}, {x}&quot;,
        &quot;shl {tmp}, 1&quot;,
        &quot;shl {x}, 2&quot;,
        &quot;add {x}, {tmp}&quot;,
        x = inout(reg) x,
        tmp = out(reg) _,
    );
}
assert_eq!(x, 4 * 6);
<span class="boring">}
</span></code></pre></pre>
<h2 id="symbol-operands-and-abi-clobbers"><a class="header" href="#symbol-operands-and-abi-clobbers">Symbol operands and ABI clobbers</a></h2>
<p>By default, <code>asm!</code> assumes that any register not specified as an output will have its contents preserved by the assembly code. The <a href="unsafe/../../reference/inline-assembly.html#abi-clobbers"><code>clobber_abi</code></a> argument to <code>asm!</code> tells the compiler to automatically insert the necessary clobber operands according to the given calling convention ABI: any register which is not fully preserved in that ABI will be treated as clobbered.  Multiple <code>clobber_abi</code> arguments may be provided and all clobbers from all specified ABIs will be inserted.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

extern &quot;C&quot; fn foo(arg: i32) -&gt; i32 {
    println!(&quot;arg = {}&quot;, arg);
    arg * 2
}

fn call_foo(arg: i32) -&gt; i32 {
    unsafe {
        let result;
        asm!(
            &quot;call *{}&quot;,
            // Function pointer to call
            in(reg) foo,
            // 1st argument in rdi
            in(&quot;rdi&quot;) arg,
            // Return value in rax
            out(&quot;rax&quot;) result,
            // Mark all registers which are not preserved by the &quot;C&quot; calling
            // convention as clobbered.
            clobber_abi(&quot;C&quot;),
        );
        result
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="register-template-modifiers"><a class="header" href="#register-template-modifiers">Register template modifiers</a></h2>
<p>In some cases, fine control is needed over the way a register name is formatted when inserted into the template string. This is needed when an architecture's assembly language has several names for the same register, each typically being a &quot;view&quot; over a subset of the register (e.g. the low 32 bits of a 64-bit register).</p>
<p>By default the compiler will always choose the name that refers to the full register size (e.g. <code>rax</code> on x86-64, <code>eax</code> on x86, etc).</p>
<p>This default can be overriden by using modifiers on the template string operands, just like you would with format strings:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut x: u16 = 0xab;

unsafe {
    asm!(&quot;mov {0:h}, {0:l}&quot;, inout(reg_abcd) x);
}

assert_eq!(x, 0xabab);
<span class="boring">}
</span></code></pre></pre>
<p>In this example, we use the <code>reg_abcd</code> register class to restrict the register allocator to the 4 legacy x86 registers (<code>ax</code>, <code>bx</code>, <code>cx</code>, <code>dx</code>) of which the first two bytes can be addressed independently.</p>
<p>Let us assume that the register allocator has chosen to allocate <code>x</code> in the <code>ax</code> register.
The <code>h</code> modifier will emit the register name for the high byte of that register and the <code>l</code> modifier will emit the register name for the low byte. The asm code will therefore be expanded as <code>mov ah, al</code> which copies the low byte of the value into the high byte.</p>
<p>If you use a smaller data type (e.g. <code>u16</code>) with an operand and forget the use template modifiers, the compiler will emit a warning and suggest the correct modifier to use.</p>
<h2 id="memory-address-operands"><a class="header" href="#memory-address-operands">Memory address operands</a></h2>
<p>Sometimes assembly instructions require operands passed via memory addresses/memory locations.
You have to manually use the memory address syntax specified by the target architecture.
For example, on x86/x86_64 using Intel assembly syntax, you should wrap inputs/outputs in <code>[]</code> to indicate they are memory operands:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

fn load_fpu_control_word(control: u16) {
    unsafe {
        asm!(&quot;fldcw [{}]&quot;, in(reg) &amp;control, options(nostack));
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="labels"><a class="header" href="#labels">Labels</a></h2>
<p>Any reuse of a named label, local or otherwise, can result in an assembler or linker error or may cause other strange behavior. Reuse of a named label can happen in a variety of ways including:</p>
<ul>
<li>explicitly: using a label more than once in one <code>asm!</code> block, or multiple times across blocks.</li>
<li>implicitly via inlining: the compiler is allowed to instantiate multiple copies of an <code>asm!</code> block, for example when the function containing it is inlined in multiple places.</li>
<li>implicitly via LTO: LTO can cause code from <em>other crates</em> to be placed in the same codegen unit, and so could bring in arbitrary labels.</li>
</ul>
<p>As a consequence, you should only use GNU assembler <strong>numeric</strong> <a href="https://sourceware.org/binutils/docs/as/Symbol-Names.html#Local-Labels">local labels</a> inside inline assembly code. Defining symbols in assembly code may lead to assembler and/or linker errors due to duplicate symbol definitions.</p>
<p>Moreover, on x86 when using the default Intel syntax, due to <a href="https://bugs.llvm.org/show_bug.cgi?id=36144">an LLVM bug</a>, you shouldn't use labels exclusively made of <code>0</code> and <code>1</code> digits, e.g. <code>0</code>, <code>11</code> or <code>101010</code>, as they may end up being interpreted as binary values. Using <code>options(att_syntax)</code> will avoid any ambiguity, but that affects the syntax of the <em>entire</em> <code>asm!</code> block. (See <a href="unsafe/inline-asm.html#options">Options</a>, below, for more on <code>options</code>.)</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut a = 0;
unsafe {
    asm!(
        &quot;mov {0}, 10&quot;,
        &quot;2:&quot;,
        &quot;sub {0}, 1&quot;,
        &quot;cmp {0}, 3&quot;,
        &quot;jle 2f&quot;,
        &quot;jmp 2b&quot;,
        &quot;2:&quot;,
        &quot;add {0}, 2&quot;,
        out(reg) a
    );
}
assert_eq!(a, 5);
<span class="boring">}
</span></code></pre></pre>
<p>This will decrement the <code>{0}</code> register value from 10 to 3, then add 2 and store it in <code>a</code>.</p>
<p>This example shows a few things:</p>
<ul>
<li>First, that the same number can be used as a label multiple times in the same inline block.</li>
<li>Second, that when a numeric label is used as a reference (as an instruction operand, for example), the suffixes â€œbâ€ (â€œbackwardâ€) or â€fâ€ (â€œforwardâ€) should be added to the numeric label. It will then refer to the nearest label defined by this number in this direction.</li>
</ul>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<p>By default, an inline assembly block is treated the same way as an external FFI function call with a custom calling convention: it may read/write memory, have observable side effects, etc. However, in many cases it is desirable to give the compiler more information about what the assembly code is actually doing so that it can optimize better.</p>
<p>Let's take our previous example of an <code>add</code> instruction:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
unsafe {
    asm!(
        &quot;add {0}, {1}&quot;,
        inlateout(reg) a, in(reg) b,
        options(pure, nomem, nostack),
    );
}
assert_eq!(a, 8);
<span class="boring">}
</span></code></pre></pre>
<p>Options can be provided as an optional final argument to the <code>asm!</code> macro. We specified three options here:</p>
<ul>
<li><code>pure</code> means that the asm code has no observable side effects and that its output depends only on its inputs. This allows the compiler optimizer to call the inline asm fewer times or even eliminate it entirely.</li>
<li><code>nomem</code> means that the asm code does not read or write to memory. By default the compiler will assume that inline assembly can read or write any memory address that is accessible to it (e.g. through a pointer passed as an operand, or a global).</li>
<li><code>nostack</code> means that the asm code does not push any data onto the stack. This allows the compiler to use optimizations such as the stack red zone on x86-64 to avoid stack pointer adjustments.</li>
</ul>
<p>These allow the compiler to better optimize code using <code>asm!</code>, for example by eliminating pure <code>asm!</code> blocks whose outputs are not needed.</p>
<p>See the <a href="unsafe/../../reference/inline-assembly.html">reference</a> for the full list of available options and their effects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macro"><a class="header" href="#macro">macro</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tests"><a class="header" href="#tests">Tests</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="write-tests"><a class="header" href="#write-tests">Write Tests</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmark"><a class="header" href="#benchmark">Benchmark</a></h1>
<p>https://doc.rust-lang.org/unstable-book/library-features/test.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-and-integration"><a class="header" href="#unit-and-integration">Unit and Integration</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assertions"><a class="header" href="#assertions">Assertions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asyncawait"><a class="header" href="#asyncawait">Async/Await</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-and-await"><a class="header" href="#async-and-await">async and await!</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future"><a class="header" href="#future">Future</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pin-and-unpin"><a class="header" href="#pin-and-unpin">Pin and Unpin</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stream"><a class="header" href="#stream">Stream</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stand-library-todo"><a class="header" href="#stand-library-todo">Stand Library todo</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
